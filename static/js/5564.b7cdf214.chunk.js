"use strict";(self.webpackChunkreact_blog=self.webpackChunkreact_blog||[]).push([[5564],{25564:(n,e,a)=>{a.r(e),a.d(e,{default:()=>c});var t=a(9950),o=a(84020),i=a(73879);class l extends i.V{constructor(n){let{attributes:e={}}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Object.assign(e,{position:{size:2,data:new Float32Array([-1,-1,3,-1,-1,3])},uv:{size:2,data:new Float32Array([0,0,2,0,0,2])}}),super(n,e)}}var s=a(5835),u=a(21393),r=a(44414);const c=n=>{let{height:e=3.5,baseWidth:a=5.5,animationType:i="rotate",glow:c=1,offset:f={x:0,y:0},noise:v=.5,transparent:m=!0,scale:h=3.6,hueShift:d=0,colorFrequency:p=1,hoverStrength:x=2,inertia:w=.05,bloom:b=1,suspendWhenOffscreen:g=!1,timeScale:M=.5}=n;const S=(0,t.useRef)(null);return(0,t.useEffect)(()=>{var n,t;const r=S.current;if(!r)return;const y=Math.max(.001,e),H=.5*Math.max(.001,a),B=Math.max(0,c),I=Math.max(0,v),F=null!==(n=null===f||void 0===f?void 0:f.x)&&void 0!==n?n:0,A=null!==(t=null===f||void 0===f?void 0:f.y)&&void 0!==t?t:0,P=m?1.5:1,C=Math.max(.001,h),E=d||0,R=Math.max(0,p||1),T=Math.max(0,b||1),_=Math.max(0,M||1),q=Math.max(0,x||1),O=Math.max(0,Math.min(1,w||.12)),z=Math.min(2,window.devicePixelRatio||1),W=new o.A({dpr:z,alpha:m,antialias:!1}),L=W.gl;L.disable(L.DEPTH_TEST),L.disable(L.CULL_FACE),L.disable(L.BLEND),Object.assign(L.canvas.style,{position:"absolute",inset:"0",width:"100%",height:"100%",display:"block"}),r.appendChild(L.canvas);const U=new l(L),k=new Float32Array(2),N=new Float32Array(2),j=new s.B(L,{vertex:"\n      attribute vec2 position;\n      void main() {\n        gl_Position = vec4(position, 0.0, 1.0);\n      }\n    ",fragment:"\n      precision highp float;\n\n      uniform vec2  iResolution;\n      uniform float iTime;\n\n      uniform float uHeight;\n      uniform float uBaseHalf;\n      uniform mat3  uRot;\n      uniform int   uUseBaseWobble;\n      uniform float uGlow;\n      uniform vec2  uOffsetPx;\n      uniform float uNoise;\n      uniform float uSaturation;\n      uniform float uScale;\n      uniform float uHueShift;\n      uniform float uColorFreq;\n      uniform float uBloom;\n      uniform float uCenterShift;\n      uniform float uInvBaseHalf;\n      uniform float uInvHeight;\n      uniform float uMinAxis;\n      uniform float uPxScale;\n      uniform float uTimeScale;\n\n      vec4 tanh4(vec4 x){\n        vec4 e2x = exp(2.0*x);\n        return (e2x - 1.0) / (e2x + 1.0);\n      }\n\n      float rand(vec2 co){\n        return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453123);\n      }\n\n      float sdOctaAnisoInv(vec3 p){\n        vec3 q = vec3(abs(p.x) * uInvBaseHalf, abs(p.y) * uInvHeight, abs(p.z) * uInvBaseHalf);\n        float m = q.x + q.y + q.z - 1.0;\n        return m * uMinAxis * 0.5773502691896258;\n      }\n\n      float sdPyramidUpInv(vec3 p){\n        float oct = sdOctaAnisoInv(p);\n        float halfSpace = -p.y;\n        return max(oct, halfSpace);\n      }\n\n      mat3 hueRotation(float a){\n        float c = cos(a), s = sin(a);\n        mat3 W = mat3(\n          0.299, 0.587, 0.114,\n          0.299, 0.587, 0.114,\n          0.299, 0.587, 0.114\n        );\n        mat3 U = mat3(\n           0.701, -0.587, -0.114,\n          -0.299,  0.413, -0.114,\n          -0.300, -0.588,  0.886\n        );\n        mat3 V = mat3(\n           0.168, -0.331,  0.500,\n           0.328,  0.035, -0.500,\n          -0.497,  0.296,  0.201\n        );\n        return W + U * c + V * s;\n      }\n\n      void main(){\n        vec2 f = (gl_FragCoord.xy - 0.5 * iResolution.xy - uOffsetPx) * uPxScale;\n\n        float z = 5.0;\n        float d = 0.0;\n\n        vec3 p;\n        vec4 o = vec4(0.0);\n\n        float centerShift = uCenterShift;\n        float cf = uColorFreq;\n\n        mat2 wob = mat2(1.0);\n        if (uUseBaseWobble == 1) {\n          float t = iTime * uTimeScale;\n          float c0 = cos(t + 0.0);\n          float c1 = cos(t + 33.0);\n          float c2 = cos(t + 11.0);\n          wob = mat2(c0, c1, c2, c0);\n        }\n\n        const int STEPS = 100;\n        for (int i = 0; i < STEPS; i++) {\n          p = vec3(f, z);\n          p.xz = p.xz * wob;\n          p = uRot * p;\n          vec3 q = p;\n          q.y += centerShift;\n          d = 0.1 + 0.2 * abs(sdPyramidUpInv(q));\n          z -= d;\n          o += (sin((p.y + z) * cf + vec4(0.0, 1.0, 2.0, 3.0)) + 1.0) / d;\n        }\n\n        o = tanh4(o * o * (uGlow * uBloom) / 1e5);\n\n        vec3 col = o.rgb;\n        float n = rand(gl_FragCoord.xy + vec2(iTime));\n        col += (n - 0.5) * uNoise;\n        col = clamp(col, 0.0, 1.0);\n\n        float L = dot(col, vec3(0.2126, 0.7152, 0.0722));\n        col = clamp(mix(vec3(L), col, uSaturation), 0.0, 1.0);\n\n        if(abs(uHueShift) > 0.0001){\n          col = clamp(hueRotation(uHueShift) * col, 0.0, 1.0);\n        }\n\n        gl_FragColor = vec4(col, o.a);\n      }\n    ",uniforms:{iResolution:{value:k},iTime:{value:0},uHeight:{value:y},uBaseHalf:{value:H},uUseBaseWobble:{value:1},uRot:{value:new Float32Array([1,0,0,0,1,0,0,0,1])},uGlow:{value:B},uOffsetPx:{value:N},uNoise:{value:I},uSaturation:{value:P},uScale:{value:C},uHueShift:{value:E},uColorFreq:{value:R},uBloom:{value:T},uCenterShift:{value:.25*y},uInvBaseHalf:{value:1/H},uInvHeight:{value:1/y},uMinAxis:{value:Math.min(H,y)},uPxScale:{value:1/(.1*(L.drawingBufferHeight||1)*C)},uTimeScale:{value:_}}}),G=new u.e(L,{geometry:U,program:j}),V=()=>{const n=r.clientWidth||1,e=r.clientHeight||1;W.setSize(n,e),k[0]=L.drawingBufferWidth,k[1]=L.drawingBufferHeight,N[0]=F*z,N[1]=A*z,j.uniforms.uPxScale.value=1/(.1*(L.drawingBufferHeight||1)*C)},D=new ResizeObserver(V);D.observe(r),V();const X=new Float32Array(9),Y=(n,e,a,t)=>{const o=Math.cos(n),i=Math.sin(n),l=Math.cos(e),s=Math.sin(e),u=Math.cos(a),r=Math.sin(a),c=o*u+i*s*r,f=-o*r+i*s*u,v=i*l,m=l*r,h=l*u,d=-s,p=-i*u+o*s*r,x=i*r+o*s*u,w=o*l;return t[0]=c,t[1]=m,t[2]=p,t[3]=f,t[4]=h,t[5]=x,t[6]=v,t[7]=d,t[8]=w,t},J=I<1e-6;let K=0;const Q=performance.now(),Z=()=>{K||(K=requestAnimationFrame(xn))},$=()=>{K&&(cancelAnimationFrame(K),K=0)},nn=()=>Math.random(),en=1*(.3+.6*nn()),an=1*(.2+.7*nn()),tn=1*(.1+.5*nn()),on=nn()*Math.PI*2,ln=nn()*Math.PI*2;let sn=0,un=0,rn=0,cn=0,fn=0;const vn=(n,e,a)=>n+(e-n)*a,mn={x:0,y:0,inside:!0},hn=()=>{mn.inside=!1},dn=()=>{mn.inside=!1};let pn=null;"hover"===i?(pn=n=>{(n=>{const e=Math.max(1,window.innerWidth),a=Math.max(1,window.innerHeight),t=.5*e,o=.5*a,i=(n.clientX-t)/(.5*e),l=(n.clientY-o)/(.5*a);mn.x=Math.max(-1,Math.min(1,i)),mn.y=Math.max(-1,Math.min(1,l)),mn.inside=!0})(n),Z()},window.addEventListener("pointermove",pn,{passive:!0}),window.addEventListener("mouseleave",hn),window.addEventListener("blur",dn),j.uniforms.uUseBaseWobble.value=0):j.uniforms.uUseBaseWobble.value="3drotate"===i?0:1;const xn=n=>{const e=.001*(n-Q);j.uniforms.iTime.value=e;let a=!0;if("hover"===i){const n=.6*q,e=.6*q;cn=(mn.inside?-mn.x:0)*e,fn=(mn.inside?mn.y:0)*n;const t=un,o=rn;if(sn=vn(sn,cn,O),un=vn(t,fn,O),rn=vn(o,0,.1),j.uniforms.uRot.value=Y(sn,un,rn,X),J){Math.abs(sn-cn)<1e-4&&Math.abs(un-fn)<1e-4&&Math.abs(rn)<1e-4&&(a=!1)}}else if("3drotate"===i){const n=e*_;sn=n*an,un=.6*Math.sin(n*en+on),rn=.5*Math.sin(n*tn+ln),j.uniforms.uRot.value=Y(sn,un,rn,X),_<1e-6&&(a=!1)}else X[0]=1,X[1]=0,X[2]=0,X[3]=0,X[4]=1,X[5]=0,X[6]=0,X[7]=0,X[8]=1,j.uniforms.uRot.value=X,_<1e-6&&(a=!1);W.render({scene:G}),K=a?requestAnimationFrame(xn):0};if(g){const n=new IntersectionObserver(n=>{n.some(n=>n.isIntersecting)?Z():$()});n.observe(r),Z(),r.__prismIO=n}else Z();return()=>{if($(),D.disconnect(),"hover"===i&&(pn&&window.removeEventListener("pointermove",pn),window.removeEventListener("mouseleave",hn),window.removeEventListener("blur",dn)),g){const n=r.__prismIO;n&&n.disconnect(),delete r.__prismIO}L.canvas.parentElement===r&&r.removeChild(L.canvas)}},[e,a,i,c,v,null===f||void 0===f?void 0:f.x,null===f||void 0===f?void 0:f.y,h,m,d,p,M,x,w,b,g]),(0,r.jsx)("div",{className:"prism-container",ref:S})}}}]);