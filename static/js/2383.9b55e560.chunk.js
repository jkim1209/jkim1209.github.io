"use strict";(self.webpackChunkreact_blog=self.webpackChunkreact_blog||[]).push([[2383],{62383:(t,e,n)=>{n.r(e),n.d(e,{default:()=>x});var o=n(9950),r=n(84020),i=n(88185),s=n(57202),a=n(68939);const c=new s.$,u=new a.e,l=new a.e;class m extends i.d{constructor(t){let{near:e=.1,far:n=100,fov:o=45,aspect:r=1,left:i,right:c,bottom:u,top:l,zoom:m=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),Object.assign(this,{near:e,far:n,fov:o,aspect:r,left:i,right:c,bottom:u,top:l,zoom:m}),this.projectionMatrix=new s.$,this.viewMatrix=new s.$,this.projectionViewMatrix=new s.$,this.worldPosition=new a.e,this.type=i||c?"orthographic":"perspective","orthographic"===this.type?this.orthographic():this.perspective()}perspective(){let{near:t=this.near,far:e=this.far,fov:n=this.fov,aspect:o=this.aspect}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return Object.assign(this,{near:t,far:e,fov:n,aspect:o}),this.projectionMatrix.fromPerspective({fov:n*(Math.PI/180),aspect:o,near:t,far:e}),this.type="perspective",this}orthographic(){let{near:t=this.near,far:e=this.far,left:n=this.left||-1,right:o=this.right||1,bottom:r=this.bottom||-1,top:i=this.top||1,zoom:s=this.zoom}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return Object.assign(this,{near:t,far:e,left:n,right:o,bottom:r,top:i,zoom:s}),n/=s,o/=s,r/=s,i/=s,this.projectionMatrix.fromOrthogonal({left:n,right:o,bottom:r,top:i,near:t,far:e}),this.type="orthographic",this}updateMatrixWorld(){return super.updateMatrixWorld(),this.viewMatrix.inverse(this.worldMatrix),this.worldMatrix.getTranslation(this.worldPosition),this.projectionViewMatrix.multiply(this.projectionMatrix,this.viewMatrix),this}updateProjectionMatrix(){return"perspective"===this.type?this.perspective():this.orthographic()}lookAt(t){return super.lookAt(t,!0),this}project(t){return t.applyMatrix4(this.viewMatrix),t.applyMatrix4(this.projectionMatrix),this}unproject(t){return t.applyMatrix4(c.inverse(this.projectionMatrix)),t.applyMatrix4(this.worldMatrix),this}updateFrustum(){this.frustum||(this.frustum=[new a.e,new a.e,new a.e,new a.e,new a.e,new a.e]);const t=this.projectionViewMatrix;this.frustum[0].set(t[3]-t[0],t[7]-t[4],t[11]-t[8]).constant=t[15]-t[12],this.frustum[1].set(t[3]+t[0],t[7]+t[4],t[11]+t[8]).constant=t[15]+t[12],this.frustum[2].set(t[3]+t[1],t[7]+t[5],t[11]+t[9]).constant=t[15]+t[13],this.frustum[3].set(t[3]-t[1],t[7]-t[5],t[11]-t[9]).constant=t[15]-t[13],this.frustum[4].set(t[3]-t[2],t[7]-t[6],t[11]-t[10]).constant=t[15]-t[14],this.frustum[5].set(t[3]+t[2],t[7]+t[6],t[11]+t[10]).constant=t[15]+t[14];for(let e=0;e<6;e++){const t=1/this.frustum[e].distance();this.frustum[e].multiply(t),this.frustum[e].constant*=t}}frustumIntersectsMesh(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.worldMatrix;if(!t.geometry.attributes.position)return!0;if(t.geometry.bounds&&t.geometry.bounds.radius!==1/0||t.geometry.computeBoundingSphere(),!t.geometry.bounds)return!0;const n=u;n.copy(t.geometry.bounds.center),n.applyMatrix4(e);const o=t.geometry.bounds.radius*e.getMaxScaleOnAxis();return this.frustumIntersectsSphere(n,o)}frustumIntersectsSphere(t,e){const n=l;for(let o=0;o<6;o++){const r=this.frustum[o];if(n.copy(r).dot(t)+r.constant<-e)return!1}return!0}}var h=n(73879),p=n(5835),d=n(21393),f=n(44414);const v=["#ffffff","#ffffff","#ffffff"],g=t=>{3===(t=t.replace(/^#/,"")).length&&(t=t.split("").map(t=>t+t).join(""));const e=parseInt(t,16);return[(e>>16&255)/255,(e>>8&255)/255,(255&e)/255]},x=t=>{let{particleCount:e=200,particleSpread:n=10,speed:i=.1,particleColors:s,moveParticlesOnHover:a=!1,particleHoverFactor:c=1,alphaParticles:u=!1,particleBaseSize:l=100,sizeRandomness:x=1,cameraDistance:w=20,disableRotation:M=!1,className:y}=t;const z=(0,o.useRef)(null),b=(0,o.useRef)({x:0,y:0});return(0,o.useEffect)(()=>{const t=z.current;if(!t)return;const o=new r.A({depth:!1,alpha:!0}),f=o.gl;t.appendChild(f.canvas),f.clearColor(0,0,0,0);const y=new m(f,{fov:15});y.position.set(0,0,w);const P=()=>{const e=t.clientWidth,n=t.clientHeight;o.setSize(e,n),y.perspective({aspect:f.canvas.width/f.canvas.height})};window.addEventListener("resize",P,!1),P();const S=e=>{const n=t.getBoundingClientRect(),o=(e.clientX-n.left)/n.width*2-1,r=-((e.clientY-n.top)/n.height*2-1);b.current={x:o,y:r}};a&&window.addEventListener("mousemove",S);const j=e,C=new Float32Array(3*j),R=new Float32Array(4*j),A=new Float32Array(3*j),F=s&&s.length>0?s:v;for(let e=0;e<j;e++){let t,n,o,r;do{t=2*Math.random()-1,n=2*Math.random()-1,o=2*Math.random()-1,r=t*t+n*n+o*o}while(r>1||0===r);const i=Math.cbrt(Math.random());C.set([t*i,n*i,o*i],3*e),R.set([Math.random(),Math.random(),Math.random(),Math.random()],4*e);const s=g(F[Math.floor(Math.random()*F.length)]);A.set(s,3*e)}const T=new h.V(f,{position:{size:3,data:C},random:{size:4,data:R},color:{size:3,data:A}}),B=new p.B(f,{vertex:"\n  attribute vec3 position;\n  attribute vec4 random;\n  attribute vec3 color;\n\n  uniform mat4 modelMatrix;\n  uniform mat4 viewMatrix;\n  uniform mat4 projectionMatrix;\n  uniform float uTime;\n  uniform float uSpread;\n  uniform float uBaseSize;\n  uniform float uSizeRandomness;\n\n  varying vec4 vRandom;\n  varying vec3 vColor;\n\n  void main() {\n    vRandom = random;\n    vColor = color;\n\n    vec3 pos = position * uSpread;\n    pos.z *= 10.0;\n\n    vec4 mPos = modelMatrix * vec4(pos, 1.0);\n    float t = uTime;\n    mPos.x += sin(t * random.z + 6.28 * random.w) * mix(0.1, 1.5, random.x);\n    mPos.y += sin(t * random.y + 6.28 * random.x) * mix(0.1, 1.5, random.w);\n    mPos.z += sin(t * random.w + 6.28 * random.y) * mix(0.1, 1.5, random.z);\n\n    vec4 mvPos = viewMatrix * mPos;\n\n    if (uSizeRandomness == 0.0) {\n      gl_PointSize = uBaseSize;\n    } else {\n      gl_PointSize = (uBaseSize * (1.0 + uSizeRandomness * (random.x - 0.5))) / length(mvPos.xyz);\n    }\n\n    gl_Position = projectionMatrix * mvPos;\n  }\n",fragment:"\n  precision highp float;\n\n  uniform float uTime;\n  uniform float uAlphaParticles;\n  varying vec4 vRandom;\n  varying vec3 vColor;\n\n  void main() {\n    vec2 uv = gl_PointCoord.xy;\n    float d = length(uv - vec2(0.5));\n\n    if(uAlphaParticles < 0.5) {\n      if(d > 0.5) {\n        discard;\n      }\n      gl_FragColor = vec4(vColor + 0.2 * sin(uv.yxx + uTime + vRandom.y * 6.28), 1.0);\n    } else {\n      float circle = smoothstep(0.5, 0.4, d) * 0.8;\n      gl_FragColor = vec4(vColor + 0.2 * sin(uv.yxx + uTime + vRandom.y * 6.28), circle);\n    }\n  }\n",uniforms:{uTime:{value:0},uSpread:{value:n},uBaseSize:{value:l},uSizeRandomness:{value:x},uAlphaParticles:{value:u?1:0}},transparent:!0,depthTest:!1}),_=new d.e(f,{mode:f.POINTS,geometry:T,program:B});let O,k=performance.now(),I=0;const E=t=>{O=requestAnimationFrame(E);const e=t-k;k=t,I+=e*i,B.uniforms.uTime.value=.001*I,a?(_.position.x=-b.current.x*c,_.position.y=-b.current.y*c):(_.position.x=0,_.position.y=0),M||(_.rotation.x=.1*Math.sin(2e-4*I),_.rotation.y=.15*Math.cos(5e-4*I),_.rotation.z+=.01*i),o.render({scene:_,camera:y})};return O=requestAnimationFrame(E),()=>{window.removeEventListener("resize",P),a&&window.removeEventListener("mousemove",S),cancelAnimationFrame(O),t.contains(f.canvas)&&t.removeChild(f.canvas)}},[e,n,i,a,c,u,l,x,w,M]),(0,f.jsx)("div",{ref:z,className:"particles-container ".concat(y||"")})}}}]);